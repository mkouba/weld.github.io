= What's the difference between `@ApplicationScoped` and `@Singleton`?

Both these contexts behave very similarly.
A single bean instance is created and shared across the application.
However, there are some important differences.

== Client Proxy

First of all, `@ApplicationScoped` is a *normal* scope whereas `@Singleton` is a *pseudo-scope* (using the CDI terminology).
What does it mean?
In the first place, for normal scopes a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxy] is always injected.
This is a container construct that delegates all method calls to the current bean instance.
While this may seem as an unnecessary overhead, it allows the container to to the following:

== Serialization

The client proxies are serializable even when the bean itself may not be.
Therefore, you can `@Inject` a normal-scoped bean into a bean with a passivating scope (such as `@SessionScoped`).
See https://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html#_the_singleton_pseudo_scope[Weld Reference Guide] for more information.

== Lazy Creation

The container initializes the bean instances of normal scoped beans lazily. 
In other words, when injecting an `@ApplicationScoped` bean a new instance is not created until actually used. 
Instead, a shared client proxy is injected.
See http://weld.cdi-spec.org/news/2016/10/25/tip3-performance/#_lazy_initialization_of_bean_instances[Weld Tip 3 - Boost performance of Weld apps] for more information.

== Circular Dependencies

Client proxies make it possible to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#injection_and_resolution[support circularities] in the bean dependency graph.

== Manual Bean Destruction

There are also some use cases where it's desirable to destroy/recreate a bean instance via `Instance.destroy()` or `AlterableContext.destroy()`. 
With client proxy in place, all injection points operate on proxy objects that can lookup the contextual instance on demand therefore making it simple and safe to replace the contextual instance for a new one. 
On the other hand injecting a direct reference and attempting the same would lead to stale bean instances or working with outdated states of those instances.
